//Recursive
//Tc->O(2^m+2^n)
//Sc->O(N)
int solver(int i, int j,string text1, string text2)
    {
        if(i<0 || j<0)
        return 0;
        
        if(text1[i]==text2[j])
        return 1+solver(i-1,j-1,text1,text2);
        
        return 0+ max(solver(i-1,j,text1,text2),solver(i,j-1,text1,text2));
    }
    int longestCommonSubsequence(string text1, string text2)
    {
        int n=text1.size();
        int m=text2.size();
        return solver(n-1,m-1,text1,text2);
    }
    //Memoization
    //Tc->O(N*M)
    //Sc->O(N)+O(N*M)
    int solver(int i, int j,string text1, string text2,vector<vector<int>> &dp)
    {
        if(i<0 || j<0)
        return 0;
        
        if(dp[i][j]!=-1)
        return dp[i][j];
        
        if(text1[i]==text2[j])
        return dp[i][j]=1+solver(i-1,j-1,text1,text2,dp);
        
        return dp[i][j]=0+ max(solver(i-1,j,text1,text2,dp),solver(i,j-1,text1,text2,dp));
    }
    int longestCommonSubsequence(string text1, string text2)
    {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> dp(n,vector<int>(m,-1));
        return solver(n-1,m-1,text1,text2,dp);
    }
    //Tabulation
    //Tc->O(N*M)
    //Sc->O(N*M)
    
    int longestCommonSubsequence(string text1, string text2)
    {
        int n=text1.size();
        int m=text2.size();
        vector<vector<int>> dp(n+1,vector<int>(m+1,0));
        for(int j=0;j<=m;j++)
        {
            dp[0][j]=0;
        }
        for(int i=0;i<=n;i++)
        {
            dp[i][0]=0;
        }
        
        for(int i=1;i<n+1;i++)
        {
            for(int j=1;j<m+1;j++)
            {
                if(text1[i-1]==text2[j-1])
                dp[i][j]= 1 + dp[i-1][j-1];

                else
                dp[i][j]= 0 + max(dp[i-1][j],dp[i][j-1]);
            }
        }
        return dp[n][m];
    }
    //Tabulation //Space optimized
    //Tc->O(N*M)
    //Sc->O(M)+O(M)
    int longestCommonSubsequence(string text1, string text2)
    {
        int n=text1.size();
        int m=text2.size();
        vector<int> prev(m+1,0);
        vector<int> cur(m+1,0);
        for(int j=0;j<=m;j++)
        {
            prev[j]=0;
        }
        for(int i=1;i<n+1;i++)
        {
            for(int j=1;j<m+1;j++)
            {
                if(text1[i-1]==text2[j-1])
                cur[j]= 1 +prev[j-1];
                else
                cur[j]= 0 + max(prev[j],cur[j-1]);
            }
            prev=cur;
            
        }
        return prev[m];
    }
